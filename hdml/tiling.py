# -*- coding: utf-8 -*-
# =============================================================================
# Copyright (C) Les solutions gÃ©ostack, Inc
#
# This file was produced as part of a research project conducted for
# The World Bank Group and is licensed under the terms of the MIT license.
#
# For inquiries, contact: info@geostack.ca
# Repository: https://github.com/geo-stack/sahel
# =============================================================================

"""
Functions for generating and managing raster tiles with overlap.
"""

# ---- Standard imports
import os.path as osp
from pathlib import Path
import math
import itertools

# ---- Third party imports
import geopandas as gpd
from osgeo import gdal
import rasterio
from rasterio.windows import from_bounds
from shapely.geometry import box

# ---- Local imports
from hdml import __datadir__ as datadir

gdal.UseExceptions()


def filter_tiles(points_path: Path, tiles_gdf: gpd.GeoDataFrame) -> dict:
    """
    Filter tiles to keep only those containing at least one observation point.

    Performs a spatial intersection between tile core areas and observation
    points to identify tiles with data. This is useful for skipping empty
    tiles during processing, significantly reducing computation time for
    sparse datasets.

    Parameters
    ----------
    points_path : Path
        Path to GeoJSON/GeoPackage file containing observation point
        geometries. Points will be automatically reprojected to match the
        tiles' CRS if needed.
    tiles_gdf : gpd.GeoDataFrame
        GeoDataFrame of tile bounding boxes generated by 'generate_tiles_bbox'.
        Must have a 'geometry' column containing tile polygons and be indexed
        by (row, col) tuples.

    RReturns
    -------
    gpd.GeoDataFrame
        Filtered GeoDataFrame containing only tiles that intersect with at
        least one observation point. Maintains the same structure and index
        as the input 'tiles_gdf'.

    See Also
    --------
    generate_tiles_bbox : Generate tile bounding boxes for a raster
    """
    # Load observation points
    points_gdf = gpd.read_file(points_path)

    # Check if CRS match (or reproject if needed)
    if points_gdf.crs != tiles_gdf.crs:
        print(f"Reprojecting points from {points_gdf. crs} "
              f"to {tiles_gdf.crs}...")
        points_gdf = points_gdf.to_crs(tiles_gdf.crs)

    # Spatial join:  keep tiles that intersect with any point
    joined = gpd.sjoin(
        tiles_gdf,
        points_gdf,
        how='inner',
        predicate='intersects'
        )

    # Get unique tile indices (remove duplicates from multiple point matches).
    filtered_tiles = tiles_gdf.loc[joined.index.unique()]

    print(f"Filtered from {len(tiles_gdf)} to {len(filtered_tiles)} tiles "
          f"containing observation points.")

    return filtered_tiles


def generate_tiles_bbox(
        input_raster: Path,
        tile_size: int = 5000,
        overlap: int = 0,
        ) -> gpd.GeoDataFrame:
    """
    Generate bounding box information for tiling a raster with overlap.

    Pre-computes the pixel coordinates for a grid of tiles covering the entire
    input raster, including both the core (non-overlapping) tile extents and
    the overlapped extents needed for accurate edge processing.

    All tiles are perfectly square (tile_size x tile_size), and may extend
    beyond the raster boundaries. When reading tiles, pixels outside the
    raster will need to be handled appropriately (e.g., using boundless read
    or padding).

    Use the 'filter_tiles' function to filter tiles (e.g., by geometry or
    points) on the returned GeoDataFrame.

    Parameters
    ----------
    input_raster : Path
        Path to the input raster file to be tiled.
    tile_size : int, optional
        Size of each tile in pixels (width and height of the core tile area,
        excluding overlap). Default is 5000.
    overlap : float, optional
        Overlap distance between adjacent tiles in the same units as the
        raster's CRS (e. g., meters for ESRI: 102022). This overlap ensures
        that edge effects are minimized when processing tiles independently.
        Default is 0.

    Returns
    -------
    gpd.GeoDataFrame
        GeoDataFrame with tile information, indexed by (row, col) tuple.

        Columns:
        - 'geometry': Polygon representing the core tile extent in the
          raster's CRS (always tile_size x tile_size, may extend beyond raster)
        - 'core_bbox_pixels': [x_start, y_start, width, height] - Core tile
          extent without overlap, in pixel coordinates relative to the input
          raster. Always [x, y, tile_size, tile_size].  May have negative
          coordinates or extend beyond raster bounds.
        - 'overlap_bbox_pixels':  [x_start, y_start, width, height] - Extended
          tile extent with overlap, in pixel coordinates. Used for processing
          to ensure accurate calculations at tile edges.  May extend beyond
          raster bounds.
        - 'crop_x_offset': int - Number of pixels to skip from the left edge
          of the overlapped tile to extract the core tile.  Always equal to
          overlap_pixels.
        - 'crop_y_offset':  int - Number of pixels to skip from the top edge
          of the overlapped tile to extract the core tile.  Always equal to
          overlap_pixels.
    """
    # Open raster to get dimensions, transform, and CRS.
    with rasterio. open(input_raster) as src:
        raster_width = src.width
        raster_height = src.height
        transform = src.transform
        crs = src.crs

        # We assume square pixels and use only x resolution.
        pixel_size = abs(transform.a)

    # Convert overlap from geographic/projected units to pixels.
    overlap_pixels = int(round(overlap / pixel_size))

    print(f"Raster resolution: {pixel_size:.2f} units/pixel")
    print(f"Raster dimensions: {raster_width} x {raster_height} pixels")
    print(f"Overlap: {overlap:.2f} units = {overlap_pixels} pixels")

    # Calculate number of tiles needed to cover the entire raster.
    n_tiles_x = math.ceil(raster_width / tile_size)
    n_tiles_y = math.ceil(raster_height / tile_size)

    print(f"Tile grid:  {n_tiles_y} rows x {n_tiles_x} cols = "
          f"{n_tiles_y * n_tiles_x} tiles")

    # Build list of tile records
    tile_records = []

    for ty, tx in itertools.product(range(n_tiles_y), range(n_tiles_x)):
        # Calculate the CORE tile extent WITHOUT overlap
        # All tiles are perfectly square:  tile_size x tile_size
        # They may extend beyond the zone/raster boundaries

        x_start = tx * tile_size
        y_start = ty * tile_size
        x_end = x_start + tile_size
        y_end = y_start + tile_size

        w = tile_size
        h = tile_size

        # Calculate tile extent WITH overlap for processing
        # Also allowed to extend beyond raster bounds
        x_start_ovlp = x_start - overlap_pixels
        y_start_ovlp = y_start - overlap_pixels
        x_end_ovlp = x_end + overlap_pixels
        y_end_ovlp = y_end + overlap_pixels

        w_ovlp = x_end_ovlp - x_start_ovlp
        h_ovlp = y_end_ovlp - y_start_ovlp

        # Convert pixel coordinates to geographic coordinates for geometry
        # Using the core tile extent (without overlap)
        minx_geo = transform.c + x_start * transform.a
        maxy_geo = transform.f + y_start * transform.e
        maxx_geo = transform.c + x_end * transform.a
        miny_geo = transform.f + y_end * transform.e

        # Create polygon geometry (note: miny < maxy for geographic coords)
        tile_geom = box(minx_geo, miny_geo, maxx_geo, maxy_geo)

        tile_records.append({
            'tile_index': (ty, tx),
            'geometry': tile_geom,
            'core_bbox_pixels': [x_start, y_start, w, h],
            'ovlp_bbox_pixels': [x_start_ovlp, y_start_ovlp, w_ovlp, h_ovlp],
            'crop_x_offset': overlap_pixels,
            'crop_y_offset': overlap_pixels
            })

    # Create GeoDataFrame
    tiles_gdf = gpd.GeoDataFrame(tile_records, crs=crs)
    tiles_gdf = tiles_gdf.set_index('tile_index', drop=True)

    print(f"Generated {len(tiles_gdf)} tiles "
          f"(all {tile_size} x {tile_size} pixels).")

    return tiles_gdf


def extract_tile(
        input_raster: Path,
        output_tile: Path,
        bbox: list,
        overwrite: bool = False,
        output_dtype: str = None
        ) -> Path:
    """
    Extract a tile from a raster using pixel coordinates.

    Parameters
    ----------
    input_raster : Path
        Path to input raster file.
    output_tile : Path
        Path where the extracted tile will be saved.
    bbox : list
        Bounding box as [x_start, y_start, width, height] in pixel coordinates.
    overwrite : bool, optional
        Whether to overwrite existing output. Default is False.
    output_dtype : str, optional
        Output GDAL data type. If None, keeps the source data type.
        Supported dtypes: 'Byte', 'UInt16', 'UInt32', 'Int16', 'Int32',
        'Float32', 'Float64'.

    Returns
    -------
    Path
        Path to the extracted tile.
    """
    if not osp.exists(output_tile) or overwrite:
        kwargs = dict(
            srcWin=bbox,
            creationOptions=['COMPRESS=DEFLATE', 'TILED=YES']
            )
        if output_dtype is not None:
            kwargs["outputType"] = getattr(gdal, f"GDT_{output_dtype}")
        gdal.Translate(
            str(output_tile),
            str(input_raster),
            **kwargs
            )

    return output_tile


def crop_tile(
        input_tile: Path,
        output_tile: Path,
        crop_x_offset: int,
        crop_y_offset: int,
        width: int,
        height: int,
        overwrite: bool = False
        ) -> Path:
    """
    Crop overlap margins from a processed tile.

    Parameters
    ----------
    input_tile : Path
        Path to the tile with overlap.
    output_tile : Path
        Path where the cropped tile will be saved.
    crop_x_offset : int
        Number of pixels to skip from left edge.
    crop_y_offset : int
        Number of pixels to skip from top edge.
    width : int
        Width of the cropped tile in pixels.
    height : int
        Height of the cropped tile in pixels.
    overwrite : bool, optional
        Whether to overwrite existing output. Default is False.

    Returns
    -------
    Path
        Path to the cropped tile.
    """
    if not osp.exists(output_tile) or overwrite:
        gdal.Translate(
            str(output_tile),
            str(input_tile),
            srcWin=[crop_x_offset, crop_y_offset, width, height],
            creationOptions=['COMPRESS=DEFLATE', 'TILED=YES']
            )

    return output_tile


def mosaic_tiles(
        tile_paths: list,
        output_raster: Path,
        overwrite: bool = False,
        cleanup_tiles: bool = False
        ) -> Path:
    """
    Mosaic tiles into a single raster using GDAL VRT and translate.

    Parameters
    ----------
    tile_paths : list
        List of Path objects pointing to tiles to mosaic.
    output_raster : Path
        Path where the mosaiced raster will be saved.
    overwrite : bool, optional
        Whether to overwrite existing output. Default is False.
    cleanup_tiles : bool, optional
        Whether to delete tiles after mosaicing. Default is False.

    Returns
    -------
    Path
        Path to the output mosaiced raster.
    """
    if output_raster.exists() and not overwrite:
        return output_raster

    # Build VRT.
    vrt_path = output_raster.with_suffix('.vrt')
    ds = gdal.BuildVRT(str(vrt_path), tile_paths)
    ds.FlushCache()
    del ds

    if output_raster.name.lower().endswith('.tif'):
        # Translate to GeoTIFF.
        gdal.Translate(
            str(output_raster),
            str(vrt_path),
            creationOptions=[
                'COMPRESS=LZW',
                'TILED=YES',
                'BIGTIFF=YES',
                'NUM_THREADS=ALL_CPUS']
            )

        # Cleanup.
        vrt_path.unlink(missing_ok=True)

    if cleanup_tiles:
        for tile in tile_paths:
            tile.unlink(missing_ok=True)

    return output_raster


if __name__ == '__main__':
    from sahel import __datadir__ as datadir
    # wtd_path = Path(datadir) / 'data' / 'wtd_obs_all.geojson'
    # output_path = Path(datadir) / 'data' / 'wtd_obs_boundary.geojson'
    # bbox_gdf = create_buffered_bounding_box(wtd_path, output_path)
