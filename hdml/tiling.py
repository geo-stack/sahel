# -*- coding: utf-8 -*-
# =============================================================================
# Copyright (C) Les solutions gÃ©ostack, Inc
#
# This file was produced as part of a research project conducted for
# The World Bank Group and is licensed under the terms of the MIT license.
#
# For inquiries, contact: info@geostack.ca
# Repository: https://github.com/geo-stack/sahel
# =============================================================================

"""
Functions for generating and managing raster tiles with overlap.
"""

# ---- Standard imports
import os.path as osp
from pathlib import Path
import math
import itertools

# ---- Third party imports
import geopandas as gpd
from osgeo import gdal
import rasterio
from rasterio.windows import from_bounds
from shapely.geometry import box

# ---- Local imports
from hdml import __datadir__ as datadir

gdal.UseExceptions()


def filter_tiles(points_path: Path, tiles_gdf: gpd.GeoDataFrame) -> dict:
    """
    Filter tiles to keep only those containing at least one observation point.

    Performs a spatial intersection between tile core areas and observation
    points to identify tiles with data. This is useful for skipping empty
    tiles during processing, significantly reducing computation time for
    sparse datasets.

    Parameters
    ----------
    points_path : Path
        Path to GeoJSON/GeoPackage file containing observation point
        geometries. Points will be automatically reprojected to match the
        tiles' CRS if needed.
    tiles_gdf : gpd.GeoDataFrame
        GeoDataFrame of tile bounding boxes generated by 'generate_tiles_bbox'.
        Must have a 'geometry' column containing tile polygons and be indexed
        by (row, col) tuples.

    RReturns
    -------
    gpd.GeoDataFrame
        Filtered GeoDataFrame containing only tiles that intersect with at
        least one observation point. Maintains the same structure and index
        as the input 'tiles_gdf'.

    See Also
    --------
    generate_tiles_bbox : Generate tile bounding boxes for a raster
    """
    # Load observation points
    points_gdf = gpd.read_file(points_path)

    # Check if CRS match (or reproject if needed)
    if points_gdf.crs != tiles_gdf.crs:
        print(f"Reprojecting points from {points_gdf. crs} "
              f"to {tiles_gdf.crs}...")
        points_gdf = points_gdf.to_crs(tiles_gdf.crs)

    # Spatial join:  keep tiles that intersect with any point
    joined = gpd.sjoin(
        tiles_gdf,
        points_gdf,
        how='inner',
        predicate='intersects'
        )

    # Get unique tile indices (remove duplicates from multiple point matches).
    filtered_tiles = tiles_gdf.loc[joined.index.unique()]

    print(f"Filtered from {len(tiles_gdf)} to {len(filtered_tiles)} tiles "
          f"containing observation points.")

    return filtered_tiles


def generate_tiles_bbox(
        input_raster: Path,
        tile_size: int = 5000,
        overlap: int = 0,
        zone_bbox: tuple = None,
        filter_points_path: Path = None
        ) -> gpd.GeoDataFrame:
    """
    Generate bounding box information for tiling a zone within a raster with
    overlap.

    Pre-computes the pixel coordinates for a grid of tiles covering either the
    full input raster or a specific rectangular zone within it, including both
    the core (non-overlapping) tile extents and the overlapped extents needed
    for accurate edge processing.

    Parameters
    ----------
    input_raster : Path
        Path to the input raster file to be tiled.
    tile_size : int, optional
        Size of each tile in pixels (width and height of the core tile area,
        excluding overlap). Default is 5000.
    overlap : float, optional
        Overlap distance between adjacent tiles in the same units as the
        raster's CRS (e.g., meters for ESRI:102022). This overlap ensures
        that edge effects are minimized when processing tiles independently.
        Default is 0.
    zone_bbox : tuple, optional
        Rectangular zone to tile in the raster's coordinate system as
        (minx, miny, maxx, maxy). Coordinates should match the raster's CRS
        (e.g., ESRI:102022 coordinates in meters). If None, tiles the entire
        raster.
    filter_points_path : Path, optional
        Path to a GeoJSON file containing observation points. If provided,
        only tiles that contain at least one point will be returned.
        This is useful for skipping empty tiles during processing.
        Default is None.

    Returns
    -------
    gpd.GeoDataFrame
        GeoDataFrame with tile information, indexed by (row, col) tuple.

        Columns:
        - 'geometry': Polygon representing the core tile extent in the
          raster's CRS
        - 'core_bbox_pixels': [x_start, y_start, width, height] - Core tile
          extent without overlap, in pixel coordinates relative to the input
          raster. Used for the final mosaic.
        - 'overlap_bbox_pixels': [x_start, y_start, width, height] - Extended
          tile extent with overlap, in pixel coordinates. Used for processing
          to ensure accurate calculations at tile edges.
        - 'crop_x_offset': int - Number of pixels to skip from the left edge
          of the overlapped tile to extract the core tile.
        - 'crop_y_offset':  int - Number of pixels to skip from the top edge
          of the overlapped tile to extract the core tile.

        Note: Tiles smaller than 10x10 pixels are excluded from the output.
    """
    # Open raster to get dimensions, transform, and CRS.
    with rasterio. open(input_raster) as src:
        raster_width = src.width
        raster_height = src.height
        transform = src.transform
        crs = src.crs

        # We assume square pixels and use only x resolution.
        pixel_size = abs(transform.a)

    # Convert overlap from geographic/projected units to pixels.
    overlap_pixels = int(round(overlap / pixel_size))

    print(f"Raster resolution: {pixel_size:.2f} units/pixel")
    print(f"Overlap: {overlap:.2f} units = {overlap_pixels} pixels")

    # Convert geographic zone bounds to pixel coordinates if provided.
    if zone_bbox is not None:
        minx, miny, maxx, maxy = zone_bbox

        # Validate that bounds are in correct order.
        if minx >= maxx or miny >= maxy:
            raise ValueError(
                f"Invalid zone bounds: minx must be < maxx and miny must "
                f"be < maxy. Got minx={minx}, miny={miny}, maxx={maxx}, "
                f"maxy={maxy}."
                )

        # Convert geographic bounds to pixel window.
        window = from_bounds(minx, miny, maxx, maxy, transform=transform)

        # Extract pixel coordinates.
        zone_x_min = int(round(window.col_off))
        zone_y_min = int(round(window.row_off))
        zone_x_max = int(round(window.col_off + window.width))
        zone_y_max = int(round(window.row_off + window.height))

        # Clamp to raster bounds.
        zone_x_min = max(0, zone_x_min)
        zone_y_min = max(0, zone_y_min)
        zone_x_max = min(raster_width, zone_x_max)
        zone_y_max = min(raster_height, zone_y_max)

        # Validate that zone intersects with raster.
        if zone_x_min >= raster_width or zone_y_min >= raster_height:
            raise ValueError(
                f"Zone bbox does not intersect with raster. "
                f"Zone in pixels: ({zone_x_min}, {zone_y_min}, "
                f"{zone_x_max}, {zone_y_max}), "
                f"Raster size: ({raster_width}, {raster_height})"
                )
        if zone_x_max <= 0 or zone_y_max <= 0:
            raise ValueError(
                f"Zone bbox does not intersect with raster. "
                f"Zone in pixels: ({zone_x_min}, {zone_y_min}, "
                f"{zone_x_max}, {zone_y_max})"
            )
        print(f"Tiling zone: geographic bounds "
              f"({minx:.2f}, {miny:.2f}, {maxx:.2f}, {maxy:.2f})")
        print(f"             pixel bounds "
              f"({zone_x_min}, {zone_y_min}, {zone_x_max}, {zone_y_max})")
    else:
        # Tile the entire raster.
        zone_x_min, zone_y_min = 0, 0
        zone_x_max, zone_y_max = raster_width, raster_height
        print(f"Tiling entire raster: {raster_width} x {raster_height} pixels")

    # Calculate zone dimensions.
    zone_width = zone_x_max - zone_x_min
    zone_height = zone_y_max - zone_y_min

    # Calculate number of tiles needed for the zone.
    n_tiles_x = math.ceil(zone_width / tile_size)
    n_tiles_y = math.ceil(zone_height / tile_size)

    # Build list of tile records
    tile_records = []

    for ty, tx in itertools.product(range(n_tiles_y), range(n_tiles_x)):
        # Calculate the CORE tile extent WITHOUT overlap (for final mosaic)
        # relative to the ZONE.
        x_start_in_zone = tx * tile_size
        y_start_in_zone = ty * tile_size
        x_end_in_zone = min(zone_width, (tx + 1) * tile_size)
        y_end_in_zone = min(zone_height, (ty + 1) * tile_size)

        # Convert to absolute raster coordinates.
        x_start = zone_x_min + x_start_in_zone
        y_start = zone_y_min + y_start_in_zone
        x_end = zone_x_min + x_end_in_zone
        y_end = zone_y_min + y_end_in_zone

        w = x_end - x_start
        h = y_end - y_start

        # Calculate tile extent WITH overlap for processing
        # Constrained by both zone bounds AND raster bounds.
        x_start_ovlp = max(0, zone_x_min + tx * tile_size - overlap_pixels)
        y_start_ovlp = max(0, zone_y_min + ty * tile_size - overlap_pixels)
        x_end_ovlp = min(
            raster_width,
            zone_x_min + (tx + 1) * tile_size + overlap_pixels
            )
        y_end_ovlp = min(
            raster_height,
            zone_y_min + (ty + 1) * tile_size + overlap_pixels
            )

        w_ovlp = x_end_ovlp - x_start_ovlp
        h_ovlp = y_end_ovlp - y_start_ovlp

        # Skip tiny edge tiles
        if w_ovlp < 10 or h_ovlp < 10:
            continue

        # Convert pixel coordinates to geographic coordinates for geometry
        # Using the core tile extent (without overlap)
        minx_geo = transform.c + x_start * transform.a
        maxy_geo = transform.f + y_start * transform.e
        maxx_geo = transform.c + x_end * transform.a
        miny_geo = transform.f + y_end * transform.e

        # Create polygon geometry (note: miny < maxy for geographic coords)
        tile_geom = box(minx_geo, miny_geo, maxx_geo, maxy_geo)

        tile_records.append({
            'tile_index': (ty, tx),
            'geometry': tile_geom,
            'core_bbox_pixels': [x_start, y_start, w, h],
            'ovlp_bbox_pixels': [x_start_ovlp, y_start_ovlp, w_ovlp, h_ovlp],
            'crop_x_offset': x_start - x_start_ovlp,
            'crop_y_offset': y_start - y_start_ovlp
            })

    # Create GeoDataFrame
    tiles_gdf = gpd.GeoDataFrame(tile_records, crs=crs)
    tiles_gdf = tiles_gdf.set_index('tile_index', drop=True)

    # Filter tiles by points if requested.
    if filter_points_path is not None:
        tiles_gdf = filter_tiles(
            points_path=filter_points_path,
            tiles_gdf=tiles_gdf
            )

    print(f"Generated {len(tiles_gdf)} valid tiles.")

    return tiles_gdf


def extract_tile(
        input_raster: Path,
        output_tile: Path,
        bbox: list,
        overwrite: bool = False
        ) -> Path:
    """
    Extract a tile from a raster using pixel coordinates.

    Parameters
    ----------
    input_raster : Path
        Path to input raster file.
    output_tile : Path
        Path where the extracted tile will be saved.
    bbox : list
        Bounding box as [x_start, y_start, width, height] in pixel coordinates.
    overwrite : bool, optional
        Whether to overwrite existing output. Default is False.

    Returns
    -------
    Path
        Path to the extracted tile.
    """
    if not osp.exists(output_tile) or overwrite:
        gdal.Translate(
            str(output_tile),
            str(input_raster),
            srcWin=bbox,
            creationOptions=['COMPRESS=DEFLATE', 'TILED=YES']
            )

    return output_tile


def crop_tile(
        input_tile: Path,
        output_tile: Path,
        crop_x_offset: int,
        crop_y_offset: int,
        width: int,
        height: int,
        overwrite: bool = False
        ) -> Path:
    """
    Crop overlap margins from a processed tile.

    Parameters
    ----------
    input_tile : Path
        Path to the tile with overlap.
    output_tile : Path
        Path where the cropped tile will be saved.
    crop_x_offset : int
        Number of pixels to skip from left edge.
    crop_y_offset : int
        Number of pixels to skip from top edge.
    width : int
        Width of the cropped tile in pixels.
    height : int
        Height of the cropped tile in pixels.
    overwrite : bool, optional
        Whether to overwrite existing output. Default is False.

    Returns
    -------
    Path
        Path to the cropped tile.
    """
    if not osp.exists(output_tile) or overwrite:
        gdal.Translate(
            str(output_tile),
            str(input_tile),
            srcWin=[crop_x_offset, crop_y_offset, width, height],
            creationOptions=['COMPRESS=DEFLATE', 'TILED=YES']
            )

    return output_tile


def mosaic_tiles(
        tile_paths: list,
        output_raster: Path,
        overwrite: bool = False,
        cleanup_tiles: bool = False
        ) -> Path:
    """
    Mosaic tiles into a single raster using GDAL VRT and translate.

    Parameters
    ----------
    tile_paths : list
        List of Path objects pointing to tiles to mosaic.
    output_raster : Path
        Path where the mosaiced raster will be saved.
    overwrite : bool, optional
        Whether to overwrite existing output. Default is False.
    cleanup_tiles : bool, optional
        Whether to delete tiles after mosaicing. Default is False.

    Returns
    -------
    Path
        Path to the output mosaiced raster.
    """
    if output_raster.exists() and not overwrite:
        return output_raster

    # Build VRT.
    vrt_path = output_raster.with_suffix('.vrt')
    ds = gdal.BuildVRT(str(vrt_path), tile_paths)
    ds.FlushCache()
    del ds

    if output_raster.name.lower().endswith('.tif'):
        # Translate to GeoTIFF.
        gdal.Translate(
            str(output_raster),
            str(vrt_path),
            creationOptions=[
                'COMPRESS=LZW',
                'TILED=YES',
                'BIGTIFF=YES',
                'NUM_THREADS=ALL_CPUS']
            )

        # Cleanup.
        vrt_path.unlink(missing_ok=True)

    if cleanup_tiles:
        for tile in tile_paths:
            tile.unlink(missing_ok=True)

    return output_raster


if __name__ == '__main__':
    from sahel import __datadir__ as datadir
    # wtd_path = Path(datadir) / 'data' / 'wtd_obs_all.geojson'
    # output_path = Path(datadir) / 'data' / 'wtd_obs_boundary.geojson'
    # bbox_gdf = create_buffered_bounding_box(wtd_path, output_path)
